/*
 * NVIC.c
 *
 *  Created on: Feb 20, 2020
 *      Author: salma
 */

#include<stdint.h>
#include "NVIC.h"

#define NVIC_BASEADDRESS 0xE000E100
#define STIR_BASEADDRESS 0xE000EF00

/*TO SET SUBPRIORITY & GROUPPRIORITY*/
#define SCB_BASE 0x0E00E008
#define SCB_AIRCR (SCB_BASE +0x0C)



typedef struct{

	uint32_t ISER[8];
	uint32_t ICER[8];
	uint32_t ISPR[8];
	uint32_t ICPR[8];
	uint32_t IABR[8];
	uint32_t IPR[20];

}NVIC_REG_t;

#define NVIC_ISER ((uint32_t *)NVIC_BASEADDRESS +0x000)
#define NVIC_ICER ((uint32_t *)NVIC_BASEADDRESS +0x080)
#define NVIC_ISPR ((uint32_t *)NVIC_BASEADDRESS +0x100)
#define NVIC_ICPR ((uint32_t *)NVIC_BASEADDRESS +0x180)
#define NVIC_IABR ((uint32_t *)NVIC_BASEADDRESS +0x200)

#define NVIC_IPR  ((uint32_t *)NVIC_BASEADDRESS +0x300)

/*GET THE REGISTER NUMBER */
#define GET_IRQ_NUM(NUMBER)	(NUMBER >> 5UL)
/*GET PIN NUMBER*/
#define SET_IRQ_NUM(NUMBER) (NUMBER & 0x1F)




/*#define NVIC_ISER0 (NVIC_BASEADDRESS +0x000)
#define NVIC_ISER1 (NVIC_BASEADDRESS +0x004)
#define NVIC_ISER2 (NVIC_BASEADDRESS +0x008)

#define NVIC_ICER0  (NVIC_BASEADDRESS +0x080)
#define NVIC_ICER1  (NVIC_BASEADDRESS +0x084)
#define NVIC_ICER2  (NVIC_BASEADDRESS +0x088)

#define NVIC_ISPR0 (NVIC_BASEADDRESS +0x100)
#define NVIC_ISPR1 (NVIC_BASEADDRESS +0x104)
#define NVIC_ISPR2 (NVIC_BASEADDRESS +0x108)

#define NVIC_ICPR0 (NVIC_BASEADDRESS +0x180)
#define NVIC_ICPR1 (NVIC_BASEADDRESS +0x184)
#define NVIC_ICPR2 (NVIC_BASEADDRESS +0x188)

#define NVIC_IABR0 (NVIC_BASEADDRESS +0x200)
#define NVIC_IABR1 (NVIC_BASEADDRESS +0x204)
#define NVIC_IABR2 (NVIC_BASEADDRESS +0x208)
// EH L HABAL DAH
#define NVIC_IPR0 (NVIC_BASEADDRESS +0x300)
#define NVIC_IPR1 (NVIC_BASEADDRESS +0x304)
#define NVIC_IPR2 (NVIC_BASEADDRESS +0x308)
#define NVIC_IPR3 (NVIC_BASEADDRESS +0x30C)
#define NVIC_IPR4 (NVIC_BASEADDRESS +0x310)
#define NVIC_IPR5 (NVIC_BASEADDRESS +0x314)
#define NVIC_IPR6 (NVIC_BASEADDRESS +0x318)
#define NVIC_IPR7 (NVIC_BASEADDRESS +0x31C)
#define NVIC_IPR8 *((volatile uint32_t *)(NVIC_BASEADDRESS +0x320))
*/


#define NVIC_STIR (STIR_BASEADDRESS + 0xE00)
#define STIR_PTR *((uint32_t *)NVIC_STIR)

#define SCB_AIRCR_KEY 0x5FA00000


/*THIS API TAKES THE INTERRUPT NUMBER &ENABLE IT*/
extern ERROR_STATUS NVIC_Enable(uint8_t IRQ_NUMBER , uint8_t PREEMPT, uint8_t SUBGROUP)
{
	ERROR_STATUS STATUS = OK;
	if( IRQ_NUMBER >240)
	{
		STATUS = NOK;
	}
	else
	{
		NVIC_ISER[GET_IRQ_NUM(IRQ_NUMBER)] =(1<<SET_IRQ_NUM(IRQ_NUMBER));

	}

	return STATUS;
}
extern ERROR_STATUS NVIC_Disable(uint8_t IRQ_NUMBER)
{
	ERROR_STATUS STATUS = OK;

	if( IRQ_NUMBER >240)
	{
		STATUS=NOK;
	}
	else
	{
		NVIC_ICER[GET_IRQ_NUM(IRQ_NUMBER)] =(1<<SET_IRQ_NUM(IRQ_NUMBER));

	}
	return STATUS;
}


extern ERROR_STATUS NVIC_Set_Pending(uint8_t IRQ_NUMBER)
{
	ERROR_STATUS STATUS = OK;

	if( IRQ_NUMBER >240)
	{
		STATUS = NOK;
	}
	else
	{
		NVIC_ISPR[GET_IRQ_NUM(IRQ_NUMBER)] =(1<<SET_IRQ_NUM(IRQ_NUMBER));

	}
	return STATUS;

}
extern ERROR_STATUS NVIC_Clear_Pending(uint8_t IRQ_NUMBER)
{
	ERROR_STATUS STATUS = OK;

	if( IRQ_NUMBER >240)
	{
		STATUS = NOK;
	}
	else
	{
		NVIC_ICPR[GET_IRQ_NUM(IRQ_NUMBER)] =(1<<SET_IRQ_NUM(IRQ_NUMBER));

	}





	return STATUS;
}

extern ERROR_STATUS IRQ_Set_Priority(uint8_t IRQ_NUMBER, uint8_t PRIORITY_NUMBER)
{
	ERROR_STATUS STATUS=OK;
	// shift b 2 3shan ngeb rakm l register w b3den ngeb rkm l byte b eni a3ml anding m3 0x3 3shan atyr ay rakm zyada b3den adrbo f 8 eshm3na 0x3 3shan l modulus aw en l probability ya 0 ,1,2,3

	NVIC_IPR[(IRQ_NUMBER >> 2)] = (PRIORITY_NUMBER << ((IRQ_NUMBER & 0x 03) * 8));

	return STATUS;
}



extern ERROR_STATUS NVIC_SW_IRQ_Enable(uint8_t IRQ_NUMBER)
{
	ERROR_STATUS STATUS=OK;
	//hardware priority assigned in STIR
	//INTERRUPT IS GENERATED BY SOFTWARE
	STIR_PTR=IRQ_NUMBER;
	return STATUS;


}
/*Level of piority to implement */
extern ERROR_STATUS NVIC_Level_Filter_based_Priority(uint8_t Priority_Level)
{
	ERROR_STATUS STATUS=OK;
	//moved the priority level value to R0
	asm("MOV R0" :: "r" (Priority_Level) : "memory");
	asm("MSR BASEPRI,R0");
	return STATUS;

}


extern ERROR_STATUS NVIC_ISActive_IRQ(uint8_t IRQ_NUMBER, uint8_t *IRQ_PTR){
	ERROR_STATUS STATUS=OK;


	if(IRQ_NUMBER >240)
	{
		STATUS=NOK;
	}
	else
	{
		uint8_t LOCAL_ActiveREG;
		LOCAL_ActiveREG = NVIC_ICPR[GET_IRQ_NUM(IRQ_NUMBER)];
		*IRQ_PTR = ((LOCAL_ActiveREG >> SET_IRQ_NUM(IRQ_NUMBER))&1);

	}



	return STATUS;
}
extern ERROR_STATUS NVIC_Set_GROUPBITS(uint8_t GROUPBITS)
{
	ERROR_STATUS STATUS=OK;


	return STATUS;
}
